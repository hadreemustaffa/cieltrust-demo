create extension if not exists "moddatetime" with schema "extensions";


create type "public"."transaction_type" as enum ('income', 'expenses');

create sequence "public"."cron_logs_id_seq";

create table "public"."budget" (
    "id" integer generated always as identity not null,
    "name" text not null,
    "amount" numeric(10,2) not null,
    "dashboard_id" integer not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone
);


alter table "public"."budget" enable row level security;

create table "public"."budget_categories" (
    "budget_id" integer not null,
    "category_id" integer not null,
    "amount" numeric(10,2),
    "spent" numeric(10,2) default 0
);


alter table "public"."budget_categories" enable row level security;

create table "public"."categories" (
    "id" integer generated always as identity not null,
    "name" text not null,
    "dashboard_id" integer not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone
);


alter table "public"."categories" enable row level security;

create table "public"."cron_logs" (
    "id" integer not null default nextval('cron_logs_id_seq'::regclass),
    "event" text not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."cron_logs" enable row level security;

create table "public"."overview" (
    "id" integer generated by default as identity not null,
    "dashboard_id" integer,
    "balance" numeric(10,2) not null default 0,
    "income" numeric(10,2) not null default 0,
    "expenses" numeric(10,2) not null default 0,
    "savings" numeric(10,2) not null default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "previous_month" jsonb
);


alter table "public"."overview" enable row level security;

create table "public"."saving_goals" (
    "id" integer generated always as identity not null,
    "name" text not null,
    "target_amount" numeric(10,2) not null,
    "saved_amount" numeric(10,2) default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "dashboard_id" integer not null
);


alter table "public"."saving_goals" enable row level security;

create table "public"."transactions" (
    "id" integer generated by default as identity not null,
    "dashboard_id" integer not null,
    "transaction_date" date not null,
    "amount" numeric(10,2) not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "reference" text,
    "budget" text,
    "category" text,
    "from" text,
    "type" transaction_type not null,
    "percent_saved" numeric(5,2)
);


alter table "public"."transactions" enable row level security;

create table "public"."upcoming_payment" (
    "id" integer generated always as identity not null,
    "name" text not null,
    "date" date not null,
    "recurrence" text not null,
    "dashboard_id" integer,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "amount" numeric(10,2),
    "is_paid" boolean default false
);


alter table "public"."upcoming_payment" enable row level security;

create table "public"."users" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "email" text,
    "first_name" text,
    "last_name" text,
    "dashboard_id" integer generated by default as identity not null
);


alter table "public"."users" enable row level security;

alter sequence "public"."cron_logs_id_seq" owned by "public"."cron_logs"."id";

CREATE INDEX budget_categories_category_id_idx ON public.budget_categories USING btree (category_id);

CREATE UNIQUE INDEX budget_categories_pkey ON public.budget_categories USING btree (budget_id, category_id);

CREATE INDEX budget_dashboard_id_idx ON public.budget USING btree (dashboard_id);

CREATE UNIQUE INDEX budget_pkey ON public.budget USING btree (id);

CREATE INDEX categories_dashboard_id_idx ON public.categories USING btree (dashboard_id);

CREATE UNIQUE INDEX categories_pkey ON public.categories USING btree (id);

CREATE UNIQUE INDEX cron_logs_pkey ON public.cron_logs USING btree (id);

CREATE INDEX overview_dashboard_id_idx ON public.overview USING btree (dashboard_id);

CREATE UNIQUE INDEX overview_pkey ON public.overview USING btree (id);

CREATE INDEX saving_goals_dashboard_id_idx ON public.saving_goals USING btree (dashboard_id);

CREATE UNIQUE INDEX saving_goals_pkey ON public.saving_goals USING btree (id);

CREATE INDEX transactions_dashboard_id_idx ON public.transactions USING btree (dashboard_id);

CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id);

CREATE INDEX transactions_transaction_date_idx ON public.transactions USING btree (transaction_date);

CREATE INDEX upcoming_payment_dashboard_id_idx ON public.upcoming_payment USING btree (dashboard_id);

CREATE UNIQUE INDEX upcoming_payment_pkey ON public.upcoming_payment USING btree (id);

CREATE UNIQUE INDEX users_dashboard_id_key ON public.users USING btree (dashboard_id);

CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id, dashboard_id);

alter table "public"."budget" add constraint "budget_pkey" PRIMARY KEY using index "budget_pkey";

alter table "public"."budget_categories" add constraint "budget_categories_pkey" PRIMARY KEY using index "budget_categories_pkey";

alter table "public"."categories" add constraint "categories_pkey" PRIMARY KEY using index "categories_pkey";

alter table "public"."cron_logs" add constraint "cron_logs_pkey" PRIMARY KEY using index "cron_logs_pkey";

alter table "public"."overview" add constraint "overview_pkey" PRIMARY KEY using index "overview_pkey";

alter table "public"."saving_goals" add constraint "saving_goals_pkey" PRIMARY KEY using index "saving_goals_pkey";

alter table "public"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "public"."upcoming_payment" add constraint "upcoming_payment_pkey" PRIMARY KEY using index "upcoming_payment_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."budget" add constraint "fk_budget_dashboard" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."budget" validate constraint "fk_budget_dashboard";

alter table "public"."budget_categories" add constraint "fk_budget" FOREIGN KEY (budget_id) REFERENCES budget(id) ON DELETE CASCADE not valid;

alter table "public"."budget_categories" validate constraint "fk_budget";

alter table "public"."budget_categories" add constraint "fk_category" FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE not valid;

alter table "public"."budget_categories" validate constraint "fk_category";

alter table "public"."categories" add constraint "fk_categories_dashboard" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."categories" validate constraint "fk_categories_dashboard";

alter table "public"."overview" add constraint "fk_overview_dashboard" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."overview" validate constraint "fk_overview_dashboard";

alter table "public"."saving_goals" add constraint "saving_goals_dashboard_id_fkey" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."saving_goals" validate constraint "saving_goals_dashboard_id_fkey";

alter table "public"."transactions" add constraint "transactions_dashboard_id_fkey" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."transactions" validate constraint "transactions_dashboard_id_fkey";

alter table "public"."transactions" add constraint "transactions_percent_saved_check" CHECK (((percent_saved >= (0)::numeric) AND (percent_saved <= (100)::numeric))) not valid;

alter table "public"."transactions" validate constraint "transactions_percent_saved_check";

alter table "public"."transactions" add constraint "transactions_reference_check" CHECK ((length(reference) <= 32)) not valid;

alter table "public"."transactions" validate constraint "transactions_reference_check";

alter table "public"."upcoming_payment" add constraint "fk_budget_dashboard" FOREIGN KEY (dashboard_id) REFERENCES users(dashboard_id) ON DELETE CASCADE not valid;

alter table "public"."upcoming_payment" validate constraint "fk_budget_dashboard";

alter table "public"."users" add constraint "users_dashboard_id_key" UNIQUE using index "users_dashboard_id_key";

alter table "public"."users" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_sum()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$BEGIN
  IF NEW.type = 'income' THEN
    UPDATE public.overview
    SET income = income + NEW.amount
    WHERE dashboard_id = NEW.dashboard_id;

    IF NEW.percent_saved IS NOT NULL THEN
      UPDATE public.overview
      SET savings = savings + (NEW.percent_saved / 100) * NEW.amount
      WHERE dashboard_id = NEW.dashboard_id;
    END IF;

  ELSIF NEW.type = 'expenses' THEN
    UPDATE public.overview
    SET expenses = expenses + NEW.amount
    WHERE dashboard_id = NEW.dashboard_id;
  END IF;

  -- Update balance correctly by adding the net change to the current balance
  IF NEW.type = 'income' THEN
    UPDATE public.overview
    SET balance = balance + NEW.amount - CASE WHEN NEW.percent_saved IS NOT NULL THEN (NEW.percent_saved / 100) * NEW.amount ELSE 0 END
    WHERE dashboard_id = NEW.dashboard_id;
  ELSIF NEW.type = 'expenses' THEN
    UPDATE public.overview
    SET balance = balance - NEW.amount
    WHERE dashboard_id = NEW.dashboard_id;
  END IF;

  RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.create_default_overview()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  INSERT INTO public.overview (dashboard_id, balance, income, expenses, savings)
  VALUES (NEW.dashboard_id, 0, 0, 0, 0);

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_user()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
	--delete from public.profiles where id = auth.uid();
	delete from auth.users where id = auth.uid();
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_by_email(email_param text)
 RETURNS text
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    SELECT u.email
    FROM public.users u
    WHERE u.email = email_param
    LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  generated_dashboard_id integer;
BEGIN
  INSERT INTO public.users (id, email, first_name, last_name)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data ->> 'first_name', NEW.raw_user_meta_data ->> 'last_name')
  RETURNING dashboard_id INTO generated_dashboard_id;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_budget_categories_spent()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Attempt the update
  UPDATE public.budget_categories
  SET spent = 0;

  -- Log success
  INSERT INTO public.cron_logs (event, created_at)
  VALUES ('Budget categories spent amount updated successfully', now());

EXCEPTION WHEN OTHERS THEN
  -- Log error
  INSERT INTO public.cron_logs (event, created_at)
  VALUES ('Error updating budget categories spent amount: ' || SQLERRM, now());
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_income_expenses()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  -- Attempt the update
  BEGIN
    UPDATE public.overview
    SET income = 0, expenses = 0;
    -- Log success
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Monthly overview data updated successfully', now());
  EXCEPTION WHEN OTHERS THEN
    -- Log error
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Error updating monthly overview data: ' || SQLERRM, now());
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_budget_spent_on_transaction()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$BEGIN
  IF NEW.type = 'expenses' AND NEW.budget IS NOT NULL AND NEW.category IS NOT NULL THEN
    UPDATE public.budget_categories bc
    SET spent = spent + NEW.amount::numeric
    FROM public.budget b, public.categories c
    WHERE bc.budget_id = b.id 
      AND bc.category_id = c.id
      AND b.name = NEW.budget
      AND c.name = NEW.category
      AND b.dashboard_id = NEW.dashboard_id
      AND c.dashboard_id = NEW.dashboard_id;
  END IF;
  
  RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_previous_month_data()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$BEGIN
 -- First operation: Update previous_month data
  BEGIN
    UPDATE public.overview
    SET previous_month = jsonb_build_object(
      'balance', balance,
      'income', income,
      'expenses', expenses,
      'savings', savings
    );
    
    -- Log success
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Monthly overview data updated successfully', now());
  EXCEPTION WHEN OTHERS THEN
    -- Log error
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Error updating monthly overview data: ' || SQLERRM, now());
    -- Re-raise the exception to prevent proceeding to the next step
    RAISE;
  END;
  
  -- Second operation: Reset income and expenses
  BEGIN
    UPDATE public.overview
    SET income = 0, expenses = 0;
    
    -- Log success
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Income and expenses reset successfully', now());
  EXCEPTION WHEN OTHERS THEN
    -- Log error
    INSERT INTO public.cron_logs (event, created_at)
    VALUES ('Error resetting income and expenses: ' || SQLERRM, now());
  END;
END;$function$
;

grant delete on table "public"."budget" to "authenticated";

grant insert on table "public"."budget" to "authenticated";

grant references on table "public"."budget" to "authenticated";

grant select on table "public"."budget" to "authenticated";

grant trigger on table "public"."budget" to "authenticated";

grant truncate on table "public"."budget" to "authenticated";

grant update on table "public"."budget" to "authenticated";

grant delete on table "public"."budget" to "service_role";

grant insert on table "public"."budget" to "service_role";

grant references on table "public"."budget" to "service_role";

grant select on table "public"."budget" to "service_role";

grant trigger on table "public"."budget" to "service_role";

grant truncate on table "public"."budget" to "service_role";

grant update on table "public"."budget" to "service_role";

grant delete on table "public"."budget_categories" to "authenticated";

grant insert on table "public"."budget_categories" to "authenticated";

grant references on table "public"."budget_categories" to "authenticated";

grant select on table "public"."budget_categories" to "authenticated";

grant trigger on table "public"."budget_categories" to "authenticated";

grant truncate on table "public"."budget_categories" to "authenticated";

grant update on table "public"."budget_categories" to "authenticated";

grant delete on table "public"."budget_categories" to "service_role";

grant insert on table "public"."budget_categories" to "service_role";

grant references on table "public"."budget_categories" to "service_role";

grant select on table "public"."budget_categories" to "service_role";

grant trigger on table "public"."budget_categories" to "service_role";

grant truncate on table "public"."budget_categories" to "service_role";

grant update on table "public"."budget_categories" to "service_role";

grant delete on table "public"."categories" to "authenticated";

grant insert on table "public"."categories" to "authenticated";

grant references on table "public"."categories" to "authenticated";

grant select on table "public"."categories" to "authenticated";

grant trigger on table "public"."categories" to "authenticated";

grant truncate on table "public"."categories" to "authenticated";

grant update on table "public"."categories" to "authenticated";

grant delete on table "public"."categories" to "service_role";

grant insert on table "public"."categories" to "service_role";

grant references on table "public"."categories" to "service_role";

grant select on table "public"."categories" to "service_role";

grant trigger on table "public"."categories" to "service_role";

grant truncate on table "public"."categories" to "service_role";

grant update on table "public"."categories" to "service_role";

grant delete on table "public"."cron_logs" to "authenticated";

grant insert on table "public"."cron_logs" to "authenticated";

grant references on table "public"."cron_logs" to "authenticated";

grant select on table "public"."cron_logs" to "authenticated";

grant trigger on table "public"."cron_logs" to "authenticated";

grant truncate on table "public"."cron_logs" to "authenticated";

grant update on table "public"."cron_logs" to "authenticated";

grant delete on table "public"."cron_logs" to "service_role";

grant insert on table "public"."cron_logs" to "service_role";

grant references on table "public"."cron_logs" to "service_role";

grant select on table "public"."cron_logs" to "service_role";

grant trigger on table "public"."cron_logs" to "service_role";

grant truncate on table "public"."cron_logs" to "service_role";

grant update on table "public"."cron_logs" to "service_role";

grant delete on table "public"."overview" to "authenticated";

grant insert on table "public"."overview" to "authenticated";

grant references on table "public"."overview" to "authenticated";

grant select on table "public"."overview" to "authenticated";

grant trigger on table "public"."overview" to "authenticated";

grant truncate on table "public"."overview" to "authenticated";

grant update on table "public"."overview" to "authenticated";

grant delete on table "public"."overview" to "service_role";

grant insert on table "public"."overview" to "service_role";

grant references on table "public"."overview" to "service_role";

grant select on table "public"."overview" to "service_role";

grant trigger on table "public"."overview" to "service_role";

grant truncate on table "public"."overview" to "service_role";

grant update on table "public"."overview" to "service_role";

grant delete on table "public"."saving_goals" to "authenticated";

grant insert on table "public"."saving_goals" to "authenticated";

grant references on table "public"."saving_goals" to "authenticated";

grant select on table "public"."saving_goals" to "authenticated";

grant trigger on table "public"."saving_goals" to "authenticated";

grant truncate on table "public"."saving_goals" to "authenticated";

grant update on table "public"."saving_goals" to "authenticated";

grant delete on table "public"."saving_goals" to "service_role";

grant insert on table "public"."saving_goals" to "service_role";

grant references on table "public"."saving_goals" to "service_role";

grant select on table "public"."saving_goals" to "service_role";

grant trigger on table "public"."saving_goals" to "service_role";

grant truncate on table "public"."saving_goals" to "service_role";

grant update on table "public"."saving_goals" to "service_role";

grant delete on table "public"."transactions" to "authenticated";

grant insert on table "public"."transactions" to "authenticated";

grant references on table "public"."transactions" to "authenticated";

grant select on table "public"."transactions" to "authenticated";

grant trigger on table "public"."transactions" to "authenticated";

grant truncate on table "public"."transactions" to "authenticated";

grant update on table "public"."transactions" to "authenticated";

grant delete on table "public"."transactions" to "service_role";

grant insert on table "public"."transactions" to "service_role";

grant references on table "public"."transactions" to "service_role";

grant select on table "public"."transactions" to "service_role";

grant trigger on table "public"."transactions" to "service_role";

grant truncate on table "public"."transactions" to "service_role";

grant update on table "public"."transactions" to "service_role";

grant delete on table "public"."upcoming_payment" to "authenticated";

grant insert on table "public"."upcoming_payment" to "authenticated";

grant references on table "public"."upcoming_payment" to "authenticated";

grant select on table "public"."upcoming_payment" to "authenticated";

grant trigger on table "public"."upcoming_payment" to "authenticated";

grant truncate on table "public"."upcoming_payment" to "authenticated";

grant update on table "public"."upcoming_payment" to "authenticated";

grant delete on table "public"."upcoming_payment" to "service_role";

grant insert on table "public"."upcoming_payment" to "service_role";

grant references on table "public"."upcoming_payment" to "service_role";

grant select on table "public"."upcoming_payment" to "service_role";

grant trigger on table "public"."upcoming_payment" to "service_role";

grant truncate on table "public"."upcoming_payment" to "service_role";

grant update on table "public"."upcoming_payment" to "service_role";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

create policy "Users can delete their own budgets."
on "public"."budget"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert budgets."
on "public"."budget"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own budgets."
on "public"."budget"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own budgets."
on "public"."budget"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can delete their own budget categories."
on "public"."budget_categories"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert budget categories."
on "public"."budget_categories"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own budget categories."
on "public"."budget_categories"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own budget categories."
on "public"."budget_categories"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can delete their own categories."
on "public"."categories"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert categories."
on "public"."categories"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own categories."
on "public"."categories"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own categories."
on "public"."categories"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can delete cron logs."
on "public"."cron_logs"
as permissive
for delete
to authenticated
using (true);


create policy "Users can insert cron logs."
on "public"."cron_logs"
as permissive
for insert
to authenticated
with check (true);


create policy "Users can update cron logs."
on "public"."cron_logs"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Users can view cron logs."
on "public"."cron_logs"
as permissive
for select
to authenticated
using (true);


create policy "Users can delete their own overview."
on "public"."overview"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert overview."
on "public"."overview"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own overview."
on "public"."overview"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own overview."
on "public"."overview"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can delete their own saving goals."
on "public"."saving_goals"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert saving goals."
on "public"."saving_goals"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own saving goals."
on "public"."saving_goals"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own saving goals."
on "public"."saving_goals"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Enable delete for users based on user_id"
on "public"."transactions"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can insert transactions."
on "public"."transactions"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can update their own transactions."
on "public"."transactions"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)))
with check ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can view their own transactions."
on "public"."transactions"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = ( SELECT users.id
   FROM users)));


create policy "Users can delete their own upcoming payments."
on "public"."upcoming_payment"
as permissive
for delete
to authenticated
using ((( SELECT users.dashboard_id
   FROM users) = dashboard_id));


create policy "Users can insert upcoming payments."
on "public"."upcoming_payment"
as permissive
for insert
to authenticated
with check ((( SELECT users.dashboard_id
   FROM users) = dashboard_id));


create policy "Users can update their own upcoming payments."
on "public"."upcoming_payment"
as permissive
for update
to authenticated
using ((( SELECT users.dashboard_id
   FROM users) = dashboard_id))
with check ((( SELECT users.dashboard_id
   FROM users) = dashboard_id));


create policy "Users can view their own upcoming payments."
on "public"."upcoming_payment"
as permissive
for select
to authenticated
using ((( SELECT users.dashboard_id
   FROM users) = dashboard_id));


create policy "Enable delete for users based on user_id"
on "public"."users"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable insert for users based on user_id"
on "public"."users"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Enable select for users based on user_id"
on "public"."users"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable update for users based on user_id"
on "public"."users"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


CREATE TRIGGER update_budget_spent_on_new_transaction_added AFTER INSERT ON public.transactions FOR EACH ROW EXECUTE FUNCTION update_budget_spent_on_transaction();

CREATE TRIGGER update_overview_on_new_transaction_added AFTER INSERT ON public.transactions FOR EACH ROW EXECUTE FUNCTION calculate_sum();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER on_new_user_created_overview AFTER INSERT ON public.users FOR EACH ROW EXECUTE FUNCTION create_default_overview();


